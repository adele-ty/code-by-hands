# 防抖
防抖是指在事件被触发n秒后再执行回调，如果在这n秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。  
应用场景：  
- 按钮提交场景：防止多次提交按钮，只执行最后提交的一次  
- 服务端验证场景：表单验证需要服务端配合，只执行一段连续的输入事件的最后一次  

代码如下：  
```c
<body>
    <div id="container"></div>
    <button>Click</button>
</body>

<script>
let count = 1;
const container = document.getElementById('container');
const button = document.querySelector('button');

function debounce(func, delay) {
  let timer = null;
  return function() {
    // 将 this 指向 button 元素
    const context = this;
    // 将 handleClick 中的参数保存在 args 中
    const args = arguments;
    clearTimeout(timer);
    timer = setTimeout(() => {
      func.apply(context, args);
    }, delay);
  };
}

function handleClick(e) {
    console.log(e)
    container.innerHTML = count++;
}
button.addEventListener('click', debounce(handleClick, 1000));
</script>
```
# 节流
节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。  
应用场景：  
- 拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动  
- 缩放场景：监控浏览器resize  
- 动画场景：避免短时间内触发动画引起性能问题  

代码如下：
```c
const throttle = (fn, wait = 50) => {
    // 上一次执行 fn 的时间
    let previous = 0;
    // 将 throttle 处理结果当作函数返回
    return function (...args) {
        // 获取当前时间，转换成时间戳，单位毫秒
        let now = +new Date();
        // 将当前时间和上一次执行函数的时间进行对比
        // 大于等待时间就把 previous 设置为当前时间并执行函数 fn
        if (now - previous > wait) {
            previous = now;
            fn.apply(this, args);
        }
    };
};

button.addEventListener('click', throttle(handleClick, 1000));
```
参考链接[防抖](https://github.com/mqyqingfeng/Blog/issues/22) [节流](https://github.com/mqyqingfeng/Blog/issues/26)  
[手写节流](https://github.com/sisterAn/JavaScript-Algorithms/issues/92)
